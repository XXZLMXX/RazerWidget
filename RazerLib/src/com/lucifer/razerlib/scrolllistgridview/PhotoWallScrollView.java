package com.lucifer.razerlib.scrolllistgridview;import java.util.ArrayList;import java.util.HashSet;import java.util.Random;import java.util.Set;import com.nostra13.universalimageloader.core.DisplayImageOptions;import com.nostra13.universalimageloader.core.ImageLoader;import com.nostra13.universalimageloader.core.ImageLoaderConfiguration;import android.content.Context;import android.content.Intent;import android.os.AsyncTask;import android.os.Environment;import android.os.Handler;import android.os.Message;import android.util.AttributeSet;import android.view.MotionEvent;import android.view.View;import android.view.View.OnTouchListener;import android.widget.ImageView;import android.widget.LinearLayout;import android.widget.ScrollView;import android.widget.Toast;import android.widget.ImageView.ScaleType;public class PhotoWallScrollView extends ScrollView implements OnTouchListener{	private Context context;		private int columnCount = 3;	private int pageCount = 15;	private int itemWidth;	private int currentPage = 0;		/**	 * 是否已加载过一次layout，这里onLayout中的初始化只需加载一次	 */	private boolean loadOnce;		private static int scrollViewHeight;		private static LinearLayout ll_photofall_container;	private ArrayList<LinearLayout> photofall_items = new ArrayList<LinearLayout>();;	private ArrayList<String> urlArrayList = new ArrayList<String>();;	private int firstColumnHeight;	private int secondColumnHeight;	private int thirdColumnHeight;		/**	 * 记录所有正在下载或等待下载的任务。	 */	private static Set<LoadImageTask> taskCollection;	private DisplayImageOptions options;	private ImageLoader imageLoader = ImageLoader.getInstance();		/**	 * 记录上垂直方向的滚动距离。	 */	private static int lastScrollY = -1;	private OnClickListener itemOnClickListener;	private int currentPosition;			/**	 * 在Handler中进行图片可见性检查的判断，以及加载更多图片的操作。	 */	private static Handler handler = new Handler()	{		public void handleMessage(android.os.Message msg)		{			PhotoWallScrollView myScrollView = (PhotoWallScrollView) msg.obj;			int scrollY = myScrollView.getScrollY();			// 如果当前的滚动位置和上次相同，表示已停止滚动			if (scrollY == lastScrollY)			{				// 当滚动的最底部，并且当前没有正在下载的任务时，开始加载下一页的图片				if (scrollViewHeight + scrollY >= ll_photofall_container.getHeight()						&& taskCollection.isEmpty())				{					myScrollView.loadMoreImages();				}			} 			else			{				lastScrollY = scrollY;				Message message = new Message();				message.obj = myScrollView;				// 5毫秒后再次对滚动位置进行判断				handler.sendMessageDelayed(message, 5);			}		};	};			public PhotoWallScrollView(Context context, AttributeSet attrs)	{		super(context, attrs);		this.context = context;				options = new DisplayImageOptions.Builder()          .showImageForEmptyUri(null)  // 设置图片Uri为空或是错误的时候显示的图片          .showImageOnFail(null)       // 设置图片加载或解码过程中发生错误显示的图片              .cacheInMemory(true)                        // 设置下载的图片是否缓存在内存中          .cacheOnDisc(true)                          // 设置下载的图片是否缓存在SD卡中          .build();		imageLoader.init(ImageLoaderConfiguration.createDefault(context));				taskCollection = new HashSet<LoadImageTask>();		setOnTouchListener(this);			}				/**	 * 进行一些关键性的初始化操作，获取MyScrollView的高度，以及得到第一列的宽度值。并在这里开始加载第一页的图片。	 */	@Override	protected void onLayout(boolean changed, int l, int t, int r, int b)	{		super.onLayout(changed, l, t, r, b);		if (changed && !loadOnce)		{			scrollViewHeight = getHeight();			itemWidth = getWidth() / columnCount;						ll_photofall_container = new LinearLayout(context);			LinearLayout.LayoutParams containerLayoutParams = new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);			ll_photofall_container.setOrientation(LinearLayout.HORIZONTAL);			ll_photofall_container.setLayoutParams(containerLayoutParams);						for (int i = 0; i < columnCount; i++)			{				LinearLayout itemLayout = new LinearLayout(context);				LinearLayout.LayoutParams itemParam = new LinearLayout.LayoutParams(itemWidth, LayoutParams.WRAP_CONTENT);				itemLayout.setPadding(2, 2, 2, 2);				itemLayout.setOrientation(LinearLayout.VERTICAL);				itemLayout.setLayoutParams(itemParam);								photofall_items.add(itemLayout);								ll_photofall_container.addView(itemLayout);							}						addView(ll_photofall_container);						loadOnce = true;			loadMoreImages();					}	}			/**	 * 监听用户的触屏事件，如果用户手指离开屏幕则开始进行滚动检测。	 */	@Override	public boolean onTouch(View v, MotionEvent event)	{		if (event.getAction() == MotionEvent.ACTION_UP)		{			Message message = new Message();			message.obj = this;			handler.sendMessageDelayed(message, 5);		}		return false;	}			/**	 * 开始加载下一页的图片，每张图片都会开启一个异步线程去下载。	 */	public void loadMoreImages()	{		if (hasSDCard())		{			int startIndex = currentPage * pageCount;			int endIndex = currentPage * pageCount + pageCount;			if (startIndex < urlArrayList.size())			{				Toast.makeText(getContext(), "正在加载...", Toast.LENGTH_SHORT).show();								if (endIndex > urlArrayList.size())				{					endIndex = urlArrayList.size();				}								for (int i = startIndex; i < endIndex; i++)				{					LoadImageTask task = new LoadImageTask();					taskCollection.add(task);					task.execute(i);				}				currentPage++;			} 			else			{				Toast.makeText(getContext(), "已没有更多图片", Toast.LENGTH_SHORT)						.show();			}		} else		{			Toast.makeText(getContext(), "未发现SD卡", Toast.LENGTH_SHORT).show();		}	}					/**	 * 判断手机是否有SD卡。	 * 	 * @return 有SD卡返回true，没有返回false。	 */	private boolean hasSDCard()	{		return Environment.MEDIA_MOUNTED.equals(Environment				.getExternalStorageState());	}			/**	 * 异步下载图片任务	 * 	 * @return 有SD卡返回true，没有返回false。	 */	public class LoadImageTask extends AsyncTask<Integer, Void, String>	{		/**		 * 记录每个图片对应的位置		 */		private int mItemPosition;		/**		 * 图片的URL地址		 */		private String mImageUrl;		/**		 * 可重复使用的ImageView		 */		private ImageView mImageView;		public LoadImageTask()		{		}		/**		 * 将可重复使用的ImageView传入		 * 		 * @param imageView		 */		public LoadImageTask(ImageView imageView)		{			mImageView = imageView;		}		@Override		protected String doInBackground(Integer... params)		{			mItemPosition = params[0];			mImageUrl = urlArrayList.get(mItemPosition);						return mImageUrl;		}		@Override		protected void onPostExecute(String url)		{			if (url != null && !"".equals(url) && !"null".equals(url))			{				LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(itemWidth, LinearLayout.LayoutParams.WRAP_CONTENT);				ImageView imageView = new ImageView(context);				imageView.setLayoutParams(params);				imageView.setScaleType(ScaleType.FIT_XY);				imageView.setPadding(5, 5, 5, 5);				imageView.setOnClickListener(itemOnClickListener);				currentPosition = mItemPosition;				imageLoader.displayImage(url, imageView);								findColumnToAdd(imageView, LinearLayout.LayoutParams.WRAP_CONTENT).addView(imageView);			}			taskCollection.remove(this);		}				/**		 * 找到此时应该添加图片的一列。原则就是对三列的高度进行判断，当前高度最小的一列就是应该添加的一列。		 * 		 * @param imageView		 * @param imageHeight		 * @return 应该添加图片的一列		 */		private LinearLayout findColumnToAdd(ImageView imageView, int imageHeight)		{			Random random = new Random();			int selected = random.nextInt(3);			return photofall_items.get(selected);						/*if (firstColumnHeight <= secondColumnHeight)			{				if (firstColumnHeight <= thirdColumnHeight)				{					firstColumnHeight += imageHeight;					return photofall_items.get(0);				}				thirdColumnHeight += imageHeight;				return photofall_items.get(2);			} 			else			{				if (secondColumnHeight <= thirdColumnHeight)				{					secondColumnHeight += imageHeight;					return photofall_items.get(1);				}				thirdColumnHeight += imageHeight;				return photofall_items.get(2);			}*/		}					}			public void setItemOnClickListener(OnClickListener ocl)	{		this.itemOnClickListener = ocl;	}			public void setColumnCount(int columncount)	{		this.columnCount = columncount;	}			public void setPageCount(int pagecount)	{		this.pageCount = pagecount;	}			public void setUrlList(ArrayList<String> urls)	{		this.urlArrayList = urls;	}					public  int getCurrentPosition()	{		return currentPosition;	}}