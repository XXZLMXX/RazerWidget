package com.lucifer.razerlib.utils;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.Closeable;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.FileWriter;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.io.StringReader;import java.io.StringWriter;import java.nio.channels.FileChannel;import android.annotation.TargetApi;import android.app.Activity;import android.content.Context;import android.content.CursorLoader;import android.database.Cursor;import android.net.Uri;import android.os.Build;import android.os.Environment;import android.os.StatFs;import android.provider.MediaStore;@TargetApi(Build.VERSION_CODES.HONEYCOMB)public class FileUtils{		private FileUtils()      {          /* cannot be instantiated */          throw new UnsupportedOperationException("cannot be instantiated");      }  			//SDCard    /**      * 判断SDCard是否可用      *       * @return      */      public static boolean isSDCardEnable()      {          return Environment.getExternalStorageState().equals(                  Environment.MEDIA_MOUNTED);      }            /**      * 获取SD卡路径      *       * @return      */      public static String getSDCardPath()      {          return Environment.getExternalStorageDirectory().getAbsolutePath()                  + File.separator;      }            /**      * 获取SD卡的剩余容量 单位byte      *       * @return      */      public static long getSDCardAllSize()      {          if (isSDCardEnable())          {              StatFs stat = new StatFs(getSDCardPath());              // 获取空闲的数据块的数量              long availableBlocks = (long) stat.getAvailableBlocks() - 4;              // 获取单个数据块的大小（byte）              long freeBlocks = stat.getAvailableBlocks();              return freeBlocks * availableBlocks;          }          return 0;      }              /**      * 获取指定路径所在空间的剩余可用容量字节数，单位byte      *       * @param filePath      * @return 容量字节 SDCard可用空间，内部存储可用空间      */      public static long getFreeBytes(String filePath)      {          // 如果是sd卡的下的路径，则获取sd卡可用容量          if (filePath.startsWith(getSDCardPath()))          {              filePath = getSDCardPath();          } else          {// 如果是内部存储的路径，则获取内存存储的可用容量              filePath = Environment.getDataDirectory().getAbsolutePath();          }          StatFs stat = new StatFs(filePath);          long availableBlocks = (long) stat.getAvailableBlocks() - 4;          return stat.getBlockSize() * availableBlocks;      }            /**     * 使用这个方法需要写外部存储的权限“<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />”，     * 调用该方法会返回应用程序的外部文件系统（Environment.getExternalStorageDirectory()）目录的绝对路径，它是用来存放应用的缓存文件，     * 它和getCacheDir目录一样，目录下的文件都会在程序被卸载的时候被清除掉。      */    public static File getSDCardCache(Context context)      {          if (isSDCardEnable())          {          	return context.getExternalCacheDir();        }          return null;      }              /**      * 获取系统存储路径      *       * @return      */      public static String getRootDirectoryPath()      {          return Environment.getRootDirectory().getAbsolutePath();      }          /**     * 返回通过Context.openFileOutput()创建和存储的文件系统的绝对路径，应用程序文件，     * 这些文件会在程序被卸载的时候全部删掉。     */    public static File getAppFile(Context context)    {    	return context.getFilesDir();    }            /**     * 返回应用程序指定的缓存目录，这些文件在设备内存不足时会优先被删除掉，     * 所以存放在这里的文件是没有任何保障的，可能会随时丢掉。     */    public static File getAppCache(Context context)    {    	return context.getCacheDir();    }            /**     * 这是一个可以存放你自己应用程序自定义的文件，你可以通过该方法返回的File实例来创建或者访问这个目录，     * 注意该目录下的文件只有你自己的程序可以访问。     */    public static File getAppDir(Context context, String path)    {    	return context.getDir(path, 0);    }                    //读写File    //创建	/**	 * 在SD卡上创建文件	 * 	 * @param fileName	 * @return	 * @throws IOException	 */    public File creatFile(String imagePathLocal)	{		File f = new File(imagePathLocal);		if (!f.exists())		{			File parentFile = f.getParentFile();			if (!parentFile.exists())			{				parentFile.mkdirs();			}			try			{				f.createNewFile();			} catch (IOException e)			{				// TODO Auto-generated catch block				e.printStackTrace();			}		}		return f;	}		/**	 * 在SD卡上创建目录	 * 	 * @param dirName	 * @return	 */	public File createSDDir(String dirName)	{		File dir = new File(dirName);		dir.mkdir();		return dir;	}		/**	 * 判断SD卡上的文件夹是否存在	 * 	 * @param fileName	 * @return	 */	public boolean isFileExist(String fileName)	{		File file = new File(fileName);		return file.exists();	}			//写文件	/**	 * 将一个InputStream里面的数据写入到SD卡中	 * 	 * @param path	 * @param fileName	 * @param input	 * @return	 */	public File savaFileFromInputStream(String path, String fileName, InputStream input)	{		int FILESIZE = 4 * 1024;				File file = null;		OutputStream output = null;		try		{			createSDDir(path);			file = creatFile(path + fileName);			output = new FileOutputStream(file);			byte[] buffer = new byte[FILESIZE];			/*			 * 真机测试，这段可能有问题，请采用下面网友提供的 while((input.read(buffer)) != -1){			 * output.write(buffer); }			 */			/* 网友提供 begin */			int length;			while ((length = (input.read(buffer))) > 0)			{				output.write(buffer, 0, length);			}			/* 网友提供 end */			output.flush();		} catch (Exception e)		{			e.printStackTrace();		} finally		{			try			{				output.close();			} catch (IOException e)			{				e.printStackTrace();			}		}		return file;	}    		public static void saveFileFromByte(byte[] fileData, String folderPath,			String fileName)	{		File folder = new File(folderPath);		folder.mkdirs();		File file = new File(folderPath, fileName);		ByteArrayInputStream is = new ByteArrayInputStream(fileData);		OutputStream os = null;		if (!file.exists())		{			try			{				file.createNewFile();				os = new FileOutputStream(file);				byte[] buffer = new byte[1024];				int len = 0;				while (-1 != (len = is.read(buffer)))				{					os.write(buffer, 0, len);				}				os.flush();			} catch (Exception e)			{				throw new RuntimeException(						FileUtils.class.getClass().getName(), e);			} finally			{				closeIO(is, os);			}		}	}				//读文件	/**	 * 从指定文件夹获取文件	 * 	 * @return 如果文件不存在则创建,如果如果无法创建文件或文件名为空则返回null	 */	public static File getSaveFile(String folderPath, String fileNmae)	{		File file = new File(getSavePath(folderPath) + File.separator				+ fileNmae);		try		{			file.createNewFile();		} catch (IOException e)		{			e.printStackTrace();		}		return file;	}		/**	 * 获取SD卡下指定文件夹的绝对路径	 * 	 * @return 返回SD卡下的指定文件夹的绝对路径	 */	public static String getSavePath(String folderName)	{		return getSaveFolder(folderName).getAbsolutePath();	}		/**	 * 获取文件夹对象	 * 	 * @return 返回SD卡下的指定文件夹对象，若文件夹不存在则创建	 */	public static File getSaveFolder(String folderName)	{		File file = new File(getSDCardPath() + File.separator + folderName				+ File.separator);		file.mkdirs();		return file;	}			/**	 * 从文件中读取文本	 * 	 * @param filePath	 * @return	 */	public static String readFile(String filePath)	{		InputStream is = null;		try		{			is = new FileInputStream(filePath);		} catch (Exception e)		{			throw new RuntimeException(FileUtils.class.getName()					+ "readFile---->" + filePath + " not found");		}		return inputStream2String(is);	}			/**	 * 从assets中读取文本	 * 	 * @param name	 * @return	 */	public static String readFileFromAssets(Context context, String name)	{		InputStream is = null;		try		{			is = context.getResources().getAssets().open(name);		} catch (Exception e)		{			throw new RuntimeException(FileUtils.class.getName()					+ ".readFileFromAssets---->" + name + " not found");		}		return inputStream2String(is);	}								//关闭文件	public static void closeIO(Closeable... closeables)	{		if (null == closeables || closeables.length <= 0)		{			return;		}		for (Closeable cb : closeables)		{			try			{				if (null == cb)				{					continue;				}				cb.close();			} catch (IOException e)			{				throw new RuntimeException(						FileUtils.class.getClass().getName(), e);			}		}	}						//File与各种形式的转化			//将字符串写入指定文件(当指定的父路径中文件夹不存在时，会最大限度去创建，以保证保存成功！) 	 public static boolean string2File(String res, String filePath) 	 {         boolean flag = true;         BufferedReader bufferedReader = null;         BufferedWriter bufferedWriter = null;         try          {             File distFile = new File(filePath);             if (!distFile.getParentFile().exists()) distFile.getParentFile().mkdirs();             bufferedReader = new BufferedReader(new StringReader(res));             bufferedWriter = new BufferedWriter(new FileWriter(distFile));             char buf[] = new char[1024];         //字符缓冲区             int len;             while ((len = bufferedReader.read(buf)) != -1)              {                     bufferedWriter.write(buf, 0, len);             }             bufferedWriter.flush();             bufferedReader.close();             bufferedWriter.close();         }          catch (IOException e)          {             e.printStackTrace();             flag = false;             return flag;         }          finally          {             if (bufferedReader != null)              {                 try                  {                         bufferedReader.close();                 }                  catch (IOException e)                  {                         e.printStackTrace();                 }             }         }         return flag; }	 	 	 //文本文件转换为指定编码的字符串     public static String file2String(File file, String encoding)      {		InputStreamReader reader = null;		StringWriter writer = new StringWriter();		try		{			if (encoding == null || "".equals(encoding.trim()))			{				reader = new InputStreamReader(new FileInputStream(file),						encoding);			} else			{				reader = new InputStreamReader(new FileInputStream(file));			}			// 将输入流写入输出流			char[] buffer = new char[1024];			int n = 0;			while (-1 != (n = reader.read(buffer)))			{				writer.write(buffer, 0, n);			}		} catch (Exception e)		{			e.printStackTrace();			return null;		} finally		{			if (reader != null)			{				try				{					reader.close();				} catch (IOException e)				{					e.printStackTrace();				}			}		}		// 返回转换结果		if (writer != null)			return writer.toString();		else			return null;	}          //获得指定文件的byte数组	public static byte[] path2Bytes(String filePath)	{		byte[] buffer = null;		try		{			File file = new File(filePath);			FileInputStream fis = new FileInputStream(file);			ByteArrayOutputStream bos = new ByteArrayOutputStream(1000);			byte[] b = new byte[1000];			int n;			while ((n = fis.read(b)) != -1)			{				bos.write(b, 0, n);			}			fis.close();			bos.close();			buffer = bos.toByteArray();		} catch (FileNotFoundException e)		{			e.printStackTrace();		} catch (IOException e)		{			e.printStackTrace();		}		return buffer;	}			//根据byte数组，生成文件	public static void byte2File(byte[] bfile, String filePath, String fileName)	{		BufferedOutputStream bos = null;		FileOutputStream fos = null;		File file = null;		try		{			File dir = new File(filePath);			if (!dir.exists() && dir.isDirectory())			{// 判断文件目录是否存在				dir.mkdirs();			}			file = new File(filePath + "\\" + fileName);			fos = new FileOutputStream(file);			bos = new BufferedOutputStream(fos);			bos.write(bfile);		} catch (Exception e)		{			e.printStackTrace();		} finally		{			if (bos != null)			{				try				{					bos.close();				} catch (IOException e1)				{					e1.printStackTrace();				}			}			if (fos != null)			{				try				{					fos.close();				} catch (IOException e1)				{					e1.printStackTrace();				}			}		}	}	//二进制转字符串	public static String byte2HexString(byte[] b) throws FileNotFoundException	{		StringBuffer sb = new StringBuffer();		String stmp = "";		for (int n = 0; n < b.length; n++)		{			stmp = Integer.toHexString(b[n] & 0XFF);			if (stmp.length() == 1)			{				sb.append("0" + stmp);			} else			{				sb.append(stmp);			}		}		return sb.toString();	}		//输入流转字符串	public static String inputStream2String(InputStream is)	{		if (null == is)		{			return null;		}		StringBuilder resultSb = null;		try		{			BufferedReader br = new BufferedReader(new InputStreamReader(is));			resultSb = new StringBuilder();			String len;			while (null != (len = br.readLine()))			{				resultSb.append(len);			}		} catch (Exception ex)		{		} finally		{			closeIO(is);		}		return null == resultSb ? null : resultSb.toString();	}			//输入流转byte[]	public static final byte[] inputStream2byte(InputStream inStream)	{		if (inStream == null)		{			return null;		}		byte[] in2b = null;		BufferedInputStream in = new BufferedInputStream(inStream);		ByteArrayOutputStream swapStream = new ByteArrayOutputStream();		int rc = 0;		try		{			while ((rc = in.read()) != -1)			{				swapStream.write(rc);			}			in2b = swapStream.toByteArray();		} catch (IOException e)		{			e.printStackTrace();		} finally		{			closeIO(inStream, in, swapStream);		}		return in2b;	}			//把uri转为File对象	public static File uri2File(Activity aty, Uri uri)	{		if (SystemTool.getSDKVersion() < 11)		{			// 在API11以下可以使用：managedQuery			String[] proj =			{ MediaStore.Images.Media.DATA };			@SuppressWarnings("deprecation")			Cursor actualimagecursor = aty.managedQuery(uri, proj, null, null,					null);			int actual_image_column_index = actualimagecursor					.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);			actualimagecursor.moveToFirst();			String img_path = actualimagecursor					.getString(actual_image_column_index);			return new File(img_path);		} 		else		{			// 在API11以上：要转为使用CursorLoader,并使用loadInBackground来返回			String[] projection =			{ MediaStore.Images.Media.DATA };			CursorLoader loader = new CursorLoader(aty, uri, projection, null,					null, null);			Cursor cursor = loader.loadInBackground();			int column_index = cursor					.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);			cursor.moveToFirst();			return new File(cursor.getString(column_index));		}	}			//复制文件	public static void copyFile(File from, File to)	{		if (null == from || !from.exists())		{			return;		}		if (null == to)		{			return;		}		FileInputStream is = null;		FileOutputStream os = null;		try		{			is = new FileInputStream(from);			if (!to.exists())			{				to.createNewFile();			}			os = new FileOutputStream(to);			copyFileFast(is, os);		} catch (Exception e)		{			throw new RuntimeException(FileUtils.class.getClass().getName(), e);		} finally		{			closeIO(is, os);		}	}		// 快速复制文件（采用nio操作）	public static void copyFileFast(FileInputStream is, FileOutputStream os)			throws IOException	{		FileChannel in = is.getChannel();		FileChannel out = os.getChannel();		in.transferTo(0, in.size(), out);	}	}